<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>README - Ruby wrapper for librelp, an easy to use library for the RELP (Reliable Event Logging Protocol) protocol.</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body class="file">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./README_rdoc.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./Relp.html">Relp</a>
  
    <li><a href="./Relp/Client.html">Relp::Client</a>
  
    <li><a href="./Relp/Error.html">Relp::Error</a>
  
    <li><a href="./Relp/Server.html">Relp::Server</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation" class="description">
  
<h1 id="label-relp+-+binding+for+the+RELP+%28Reliable+Event+Logging+Protocol%29+protocol">relp - binding for the RELP (Reliable Event Logging Protocol) protocol</h1>

<p>© 2012 Lourens Naudé (methodmissing), Erkki Eilonen (erkki)</p>

<pre>http://github.com/methodmissing/relp</pre>

<h2 id="label-About+the+RELP+protocol">About the RELP protocol</h2>

<p>The RELP protocol is a reliable (read: no message loss, but see caveats
below) solution to vanilla tcp event / message transfer. It supports
full-duplex communication through a command-response model. Commands and
responses are bound by an increasing transaction number.</p>

<p>Caveats :</p>
<ul><li>
<p>Minor message duplication may occur if a network connection between the
RELP client and RELP server breaks after the client could successfully send
some messages but the server could not acknowledge them. Very very slim
chance, but possible.</p>
</li></ul>

<p>It was initially designed for rsyslog-to-rsyslog communication, but can be
used for various other applications. You can reference the protocol
specification <a href="http://www.librelp.com/relp.html">here</a></p>

<h2 id="label-About+librelp">About librelp</h2>

<p>Quote from the librelp <a href="http://www.librelp.com/">homepage</a> :</p>

<p>“librelp is an easy to use library for the RELP protocol. RELP in turn
provides reliable event logging over the network (and consequently RELP
stands for Reliable Event Logging Protocol). RELP was initiated by Rainer
Gerhards after he was finally upset by the lossy nature of plain tcp syslog
and wanted a cure for all these dangling issues.”</p>

<h2 id="label-About+this+binding">About this binding</h2>
<ul><li>
<p>Original concept and motivation sparked from syslog per process facility
limitations.</p>
</li><li>
<p>It’s friendly to the thread scheduler - uses rb_thread_select and the MRI
1.9 and Rubinius specific rb_thread_blocking_region feature.</p>
</li><li>
<p>It depends on a librelp fork @ <a
href="https://github.com/methodmissing/librelp">github.com/methodmissing/librelp</a>
with a single change set that address issues with platform specific
clock_gettime use.</p>
</li><li>
<p>Supports a very simple client / server model and does not assume any
responsibility for message encoding etc.</p>
</li><li>
<p>We try to bundle librelp with this extension to remove any third party
installation overhead for end users. This is work in progress and may fail
on some platforms in the interim.</p>
</li><li>
<p>The API isn’t set in stone yet - it likely will change.</p>
</li></ul>

<h2 id="label-Usage">Usage</h2>

<p>Here’s a few basic examples. Please refer to documentation (<a
href="http://methodmissing.github.com/relp/">methodmissing.github.com/relp/</a>)
and test cases (<a
href="https://github.com/methodmissing/relp/tree/master/test">github.com/methodmissing/relp/tree/master/test</a>)
for detailed usage information.</p>

<h3 id="label-High+level+API">High level API</h3>

<pre class="ruby"><span class="ruby-comment"># client process</span>
<span class="ruby-identifier">client</span> = <span class="ruby-constant">Relp</span><span class="ruby-operator">::</span><span class="ruby-constant">Client</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">AF_INET</span>, <span class="ruby-string">'localhost'</span>, <span class="ruby-value">518</span>)
<span class="ruby-identifier">client</span>.<span class="ruby-identifier">send</span>(<span class="ruby-string">&quot;test message&quot;</span>)

<span class="ruby-comment"># server process</span>
<span class="ruby-identifier">receive_callback</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">host</span>,<span class="ruby-identifier">ip</span>,<span class="ruby-identifier">msg</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-node">&quot;got #{msg} from #{ip}&quot;</span> }
<span class="ruby-comment"># This call blocks the current thread of execution. Messages are processed via the callback Proc</span>
<span class="ruby-identifier">server</span> = <span class="ruby-constant">Relp</span><span class="ruby-operator">::</span><span class="ruby-constant">Server</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-value">518</span>, <span class="ruby-identifier">receive_callback</span>)
</pre>

<h3 id="label-Low+level+API">Low level API</h3>

<p>All protocol and connection state’s kept within a single context, the
Relp::Engine. An engine must be instantiated and passed as an initializer
argument to <a href="Relp/Client.html">Relp::Client</a> and <a
href="Relp/Server.html">Relp::Server</a> instances. Each of these roles
also support a destroy method which will gracefully shutdown the engine and
transfer state. This pretty much resembles the <a
href="http://rsyslog.com">rsyslog</a> Output / Input module design and we
had to jump through some hoops in order to hide these details from the end
user.</p>

<pre class="ruby"><span class="ruby-comment"># client process</span>
<span class="ruby-identifier">engine</span> = <span class="ruby-constant">Relp</span><span class="ruby-operator">::</span><span class="ruby-constant">Engine</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">client</span> = <span class="ruby-constant">Relp</span><span class="ruby-operator">::</span><span class="ruby-constant">Client</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">engine</span>)
<span class="ruby-identifier">client</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">AF_INET</span>, <span class="ruby-string">'localhost'</span>, <span class="ruby-value">518</span>)

<span class="ruby-comment"># server process</span>
<span class="ruby-identifier">engine</span> = <span class="ruby-constant">Relp</span><span class="ruby-operator">::</span><span class="ruby-constant">Engine</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">server</span> = <span class="ruby-constant">Relp</span><span class="ruby-operator">::</span><span class="ruby-constant">Server</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">engine</span>)
<span class="ruby-identifier">server</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-value">518</span>)
<span class="ruby-identifier">callback</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">host</span>,<span class="ruby-identifier">ip</span>,<span class="ruby-identifier">msg</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-node">&quot;got #{msg} from #{ip}&quot;</span> }
<span class="ruby-identifier">server</span>.<span class="ruby-identifier">on_receive</span>(<span class="ruby-identifier">callback</span>)
<span class="ruby-comment"># starts the engine loop - blocks current thread</span>
<span class="ruby-identifier">engine</span>.<span class="ruby-identifier">run</span>
</pre>

<h2 id="label-Performance">Performance</h2>

<p>Don’t know and in the interim, don’t care. It’s fast enough for most
use cases - shipping events to an event sink in a reliable manner.
There’s two things to note here :</p>
<ul><li>
<p><a href="http://www.librelp.com">librelp</a> uses the <a
href="http://en.wikipedia.org/wiki/Select_(Unix)">select</a> syscall for
I/O multiplexing. This is primarily for portability but also mirrors the <a
href="http://rsyslog.com/">rsyslog</a> Output -&gt; Input module and
subsequent <a href="http://www.librelp.com">librelp</a> design. It’s thus
not designed for thousands on concurrent clients on the server side, for
which a platform specific epoll, kqueue etc. implementation is preferred.</p>
</li><li>
<p>The RELP protocol uses consistent framing - there’s thus additional
parsing overhead for participants. This is negligible though.</p>
</li></ul>

<p>Use <a href="http://rsyslog.com/">rsyslog</a> with the <a
href="http://rsyslog.com/doc/imrelp.html">RELP Input Module</a> as an event
sink if you must.</p>

<h2 id="label-Resources">Resources</h2>
<ul><li>
<p>RELP protocol spec - <a
href="http://www.librelp.com/relp.html">www.librelp.com/relp.html</a></p>
</li><li>
<p>librelp - <a href="http://www.librelp.com">www.librelp.com</a></p>
</li><li>
<p>rsyslog - <a href="http://rsyslog.com">rsyslog.com</a></p>
</li><li>
<p>rsyslog RELP Input Module - <a
href="http://rsyslog.com/doc/imrelp.html">rsyslog.com/doc/imrelp.html</a></p>
</li></ul>

<h2 id="label-Requirements">Requirements</h2>
<ul><li>
<p>A POSIX compliant OS, known to work well on Linux, BSD variants and Mac OS
X</p>
</li><li>
<p>Ruby MRI 1.8, 1.9 or Rubinius (JRuby capi support forthcoming)</p>
</li><li>
<p>A C compiler</p>
</li></ul>

<h2 id="label-Installation">Installation</h2>

<p>Rubygems installation</p>

<pre>gem install relp</pre>

<p>Building from source</p>

<pre>git clone git@github.com:methodmissing/relp.git
rake</pre>

<p>Running tests</p>

<pre>rake test</pre>

<h2 id="label-TODO">TODO</h2>
<ul><li>
<p>Remove the debug callback function and disable debug librelp build</p>
</li><li>
<p>Do not allow further method calls on lower level destroy calls on <a
href="Relp/Client.html">Relp::Client</a> or <a
href="Relp/Server.html">Relp::Server</a> instances</p>
</li><li>
<p>Sanity check on_receive cb arity + test cases for error conditions in
command callbacks</p>
</li><li>
<p>Fix Rubinius and JRuby compile</p>
</li><li>
<p>rb_thread_blocking_region on connect, bind, send + explicit engine destroy</p>
</li><li>
<p>engine destruct on handler error or error handler callback API ?</p>
</li><li>
<p>Respect that <a href="Relp/Server.html">Relp::Server</a> could bind to
multiple ports</p>
</li><li>
<p>examples</p>
</li><li>
<p>publish gem</p>
</li></ul>

<h2 id="label-Contact%2C+feedback+and+bugs">Contact, feedback and bugs</h2>

<p>This project is still work in progress. Please log bugs and suggestions at
<a
href="https://github.com/methodmissing/relp/issues">github.com/methodmissing/relp/issues</a></p>

</div>



<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

